package org.julheinz.madtodoapp;

import android.Manifest;
import android.app.Activity;
import android.app.DatePickerDialog;
import android.app.TimePickerDialog;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.database.Cursor;
import android.net.Uri;
import android.os.Bundle;
import android.provider.ContactsContract;
import android.util.Log;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.widget.ArrayAdapter;
import android.widget.DatePicker;
import android.widget.ListView;
import android.widget.TimePicker;

import androidx.activity.result.ActivityResultLauncher;
import androidx.activity.result.contract.ActivityResultContracts;
import androidx.annotation.NonNull;
import androidx.appcompat.app.AppCompatActivity;
import androidx.databinding.DataBindingUtil;
import androidx.fragment.app.DialogFragment;
import androidx.lifecycle.ViewModelProvider;

import com.google.android.material.snackbar.Snackbar;

import org.julheinz.contacts.ContactListAdapter;
import org.julheinz.entities.ContactEntity;
import org.julheinz.entities.TaskEntity;
import org.julheinz.madtodoapp.databinding.DetailViewBinding;
import org.julheinz.viewmodel.DetailviewViewModel;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Objects;

public class DetailViewActivity extends AppCompatActivity implements DeleteDialogFragment.DeleteDialogListener, TimePickerDialog.OnTimeSetListener, DatePickerDialog.OnDateSetListener {
    private static final String LOG_TAG = DetailViewActivity.class.getSimpleName();

    public static final String ARG_TASK = "task";
    private DetailviewViewModel viewModel;
    public int doneCheckboxVisibility;

    public List<ContactEntity> contactsList;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        DetailViewBinding itemBinding = DataBindingUtil.setContentView(this, R.layout.detail_view); //bind this activity to detail_view.xml
        // DetailViewBinding class gets automatically generated by data binding library. named after xml file (detail_view.xml -> DetailViewBinding.java)
        Intent detailViewIntentFromOverview = getIntent();
        String action = detailViewIntentFromOverview.getAction();

        // if action is called for creating a task, change layout
        if (Objects.equals(action, "android.intent.action.INSERT")) {
            prepareLayoutForCreate();
        }

        itemBinding.setLifecycleOwner(this); // enable observing of view model
        this.viewModel = new ViewModelProvider(this).get(DetailviewViewModel.class);
        itemBinding.setViewmodel(this.viewModel);
        itemBinding.setActivity(this);

        if (this.viewModel.getTaskEntity() == null) {
            //in case this activity gets called to edit a task, get the TaskEntity from intent
            TaskEntity taskFromIntent = (TaskEntity) detailViewIntentFromOverview.getSerializableExtra(ARG_TASK); // get TaskEntity (not same instance because it is serializable)
            TaskEntity task = taskFromIntent;
            if (taskFromIntent == null) { //in case this activity gets called to create a task instead of edit one, create a new TaskEntity
                task = new TaskEntity();
                Log.i(LOG_TAG, "created new empty task: " + task );
            }else{
                Log.i(LOG_TAG, "got task from overview " + task);
            }
            this.viewModel.setTaskEntity(task);
        }

        // listen to what the most recent user event is and act accordingly. user event gets set in layout databound to viewmodel
        this.viewModel.getUserEvent().observe(this, event ->{
            switch (event){
                case SET_DATE:
                    showDatePickerDialog();
                    break;
                case SET_TIME:
                    showTimePickerDialog();
                    break;
                case CANCEL:
                    cancelEdit();
                    break;
                case SAVE:
                    saveTask();
                    break;
                case FAVORITE:
                    //TODO: Method for toggling icon
                    break;
            }
        });

        //List view for contacts
        HashSet<String> contacts = this.viewModel.getTaskEntity().getContacts();
        contactsList = new ArrayList<>();
        for(String contact : contacts){
            //create contact entities
            ContactEntity contactEntity = new ContactEntity(contact);
            contactsList.add(contactEntity);
            Log.i(LOG_TAG, "creating contact " + contactEntity);
        }

        ListView listView = findViewById(R.id.contactListView); // listview element in detailview_activity.xml = container for list
        ArrayAdapter<ContactEntity> listViewAdapter = new ContactListAdapter(this, R.id.contactListView, contactsList,  this.getLayoutInflater()); //instantiate adapter
        listView.setAdapter(listViewAdapter);

    }

    public void saveTask() {
        Log.i(LOG_TAG, "Task saved:" + viewModel.getTaskEntity().toString());
        Intent returnToCallerWithValueIntent = new Intent(Intent.ACTION_EDIT);
        returnToCallerWithValueIntent.putExtra(ARG_TASK, viewModel.getTaskEntity()); //return created/updated task to calling activity
        setResult(Activity.RESULT_OK, returnToCallerWithValueIntent);
        finish(); //close activity and return to caller
    }

    public void cancelEdit() {
        Intent returnToCallerWhenCancelled = new Intent();
        setResult(Activity.RESULT_CANCELED, returnToCallerWhenCancelled);
        finish(); //close activity and return to caller
    }

    public void deleteTask() {
        Log.i(LOG_TAG, "Task deleted:" + viewModel.getTaskEntity().toString());
        Intent returnToCallerWithValueIntent = new Intent(Intent.ACTION_DELETE);
        returnToCallerWithValueIntent.putExtra(ARG_TASK, viewModel.getTaskEntity());
        setResult(Activity.RESULT_OK, returnToCallerWithValueIntent);
        finish(); //close activity and return to caller
    }

    /**
     * Show a dialog to confirm before deleting
     */
    public void confirmDeletionViaDialog() {
        DialogFragment dialogFragment = new DeleteDialogFragment();
        dialogFragment.show(getSupportFragmentManager(), "DeleteDialogFragment");
    }
    /**
     * Listener for confirm button in Confirm Deletion Dialog
     */
    @Override
    public void onDialogPositiveClick(DialogFragment dialog) {
        deleteTask();
    }

    /**
     * Listener for cancel button in Confirm Deletion Dialog
     */
    @Override
    public void onDialogNegativeClick(DialogFragment dialog) {
        dialog.dismiss();
    }

    public void showTimePickerDialog() {
        TimePickerFragment timePickerFragment = new TimePickerFragment();
        timePickerFragment.show(getSupportFragmentManager(), "timePickerDueDate");
    }

    public void showDatePickerDialog() {
        DatePickerFragment datePickerFragment = new DatePickerFragment();
        datePickerFragment.show(getSupportFragmentManager(), "datePickerDueDate");
    }

    /**
     * Listen to user finishing setting due time in TimePickerFragment in TimepickerDialog.
     */
    @Override
    public void onTimeSet(TimePicker view, int hourOfDay, int minute) {
        this.viewModel.getDateTimeHelper().getValue().setDueTime(hourOfDay, minute);
    }

    /**
     * Listen to user finishing setting due date in DatePickerDialog.
     */
    @Override
    public void onDateSet(DatePicker view, int year, int month, int dayOfMonth) {
        Log.i(LOG_TAG, "Set due date to: " + year + "/" + month + "/" + dayOfMonth);
        this.viewModel.getDateTimeHelper().getValue().setDueDate(year, month, dayOfMonth);
    }

    /**
     * Show different elements if activity was called for task creation
     */
    public void prepareLayoutForCreate() {
        setDoneCheckboxVisibility(View.GONE);
        //TODO: hide delete option in menu
    }

    public int getDoneCheckboxVisibility() {
        return doneCheckboxVisibility;
    }

    public void setDoneCheckboxVisibility(int doneCheckboxVisibility) {
        this.doneCheckboxVisibility = doneCheckboxVisibility;
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu){
        getMenuInflater().inflate(R.menu.activity_detailview_menu, menu);
        return true;
    }

    @Override
    public boolean onOptionsItemSelected(@NonNull MenuItem item) {
        if(item.getItemId() == R.id.addContact){
            selectContact();
            return true;
        }else if(item.getItemId() == R.id.deleteTask){
            //TODO: don't show this item in menu if task is being created
            this.confirmDeletionViaDialog();
            return true;
        }else{
            return super.onOptionsItemSelected(item);
        }
    }

    private void selectContact(){
        //Intent to call the app which is registered to handle contacts on the device
        Intent selectContactOIntent = new Intent(Intent.ACTION_PICK, ContactsContract.Contacts.CONTENT_URI);
        selectContactLauncher.launch(selectContactOIntent);
    }


    /**
     * This is field. ActivityResultLauncher to launch the intent to the contacts app and handle the result
     * Has two arguments:
     * 1. How the activity should be called (with result)
     * 2. what to do with the result
     */
    private final ActivityResultLauncher<Intent> selectContactLauncher = registerForActivityResult(
            new ActivityResultContracts.StartActivityForResult(),
            result -> {
                if(result.getResultCode() == Activity.RESULT_OK && (result.getData() != null) ){
                    onContactSelected(result.getData());
                }else{
                    String message = "Something went wrong with getting the contact";
                    showSnackbar(message);
                    Log.i(LOG_TAG, message);
                }
            }
    );


    /**
     * Get the ids of the selected contacts from the intent returned from the contacts app.
     * @param returnIntentFromContactsApp the contact that was returned from the contact app, wrapped in an intent
     */
    private void onContactSelected(Intent returnIntentFromContactsApp){
        Uri contactUri = returnIntentFromContactsApp.getData(); //get the uri for the contact e.g. content://com.android.contacts/contacts/lookup/0r6-344C2A445C3A4E3E2A/6

        // ContentResolver.query accesses the content in the given uri, acts like accessing a relational db.
        // That's why we can use java's cursor class (which is usually used to access the result set of a db query)

        try(Cursor cursor = getContentResolver().query(contactUri, null, null, null)){
            if (cursor.moveToFirst()) {
                int displayNameColumnIndex = cursor.getColumnIndex(ContactsContract.Contacts.DISPLAY_NAME); //get the index for the column for the contact name
                String contactName = cursor.getString(displayNameColumnIndex);
                int contactIdColumnIndex = cursor.getColumnIndex(ContactsContract.Contacts._ID);
                long contactID = cursor.getLong(contactIdColumnIndex);
                Log.i(LOG_TAG, "Contact: " +  contactID + " " + contactName);
                this.viewModel.getTaskEntity().getContacts().add(String.valueOf(contactID)); //save contactID in taskEntity
                //check if permission to read contacts has already been granted
                int hasReadContactPermission = checkSelfPermission(Manifest.permission.READ_CONTACTS);
                if(hasReadContactPermission != PackageManager.PERMISSION_GRANTED){
                    //if not, ask user for permission
                    requestPermissions(new String[]{Manifest.permission.READ_CONTACTS}, 10);
                    return;
                }


            }
        }
    }

    @Override
    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults);
        Log.i(LOG_TAG, "onRequestPermissionsResult: " + Arrays.asList(permissions) + ": " + Arrays.toString(grantResults));
    }

    //TODO: this should return the data only for one id, when that id is supposed to be SMSed or emailed
    /**
     * get phone number and email from selected contact
     * @param contactId id for contact in android
     */
    private void showDetailsForContactId(long contactId){
        //get phone book data, like in sql SELECT * FROM Phone WHERE contactId = contactId
        // 1. what table to select from, here phone
        // 2. what columns to get: null means all (like * in SQL)
        // 3. query
        // 4. what gets inserted at ? for the above query, as String array
        // 5. sort order
        String[] contactIDs = new String[]{String.valueOf(contactId)};
        try(Cursor cursor = getContentResolver().query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI, null, "contact_id=?", contactIDs, null)){
            while(cursor.moveToNext()){
                int phoneNumberColumnIndex = cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER);
                int phoneNumberTypeColumnIndex = cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.TYPE);
                String currentPhoneNumber = cursor.getString(phoneNumberColumnIndex);
                int currentNumberType = cursor.getInt(phoneNumberTypeColumnIndex);
                boolean isMobileNumber = currentNumberType == ContactsContract.CommonDataKinds.Phone.TYPE_MOBILE;
                Log.i(LOG_TAG, currentPhoneNumber + " " + " is Mobile? " + isMobileNumber);
            }
        }

        //get email
        try(Cursor cursor = getContentResolver().query(ContactsContract.CommonDataKinds.Email.CONTENT_URI, null, "contact_id=?", contactIDs, null)){
            while(cursor.moveToNext()){
                int emailColumnIndex = cursor.getColumnIndex(ContactsContract.CommonDataKinds.Email.ADDRESS);
                String email = cursor.getString(emailColumnIndex);
                Log.i(LOG_TAG, "Email: " + email);
            }

        }
    }
    private void showSnackbar(String msg) {
        Snackbar.make(findViewById(R.id.DetailView), msg, Snackbar.LENGTH_SHORT).show();
    }



}



