package org.julheinz.madtodoapp;

import android.Manifest;
import android.app.Activity;
import android.app.DatePickerDialog;
import android.app.TimePickerDialog;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.database.Cursor;
import android.net.Uri;
import android.os.Bundle;
import android.provider.ContactsContract;
import android.util.Log;
import android.view.Menu;

import android.view.View;
import android.widget.ArrayAdapter;
import android.widget.DatePicker;
import android.widget.ListView;
import android.widget.TimePicker;

import androidx.activity.result.ActivityResultLauncher;
import androidx.activity.result.contract.ActivityResultContracts;
import androidx.annotation.NonNull;
import androidx.appcompat.app.AppCompatActivity;
import androidx.appcompat.widget.Toolbar;
import androidx.databinding.DataBindingUtil;
import androidx.fragment.app.DialogFragment;
import androidx.lifecycle.ViewModelProvider;

import com.google.android.material.snackbar.Snackbar;

import org.julheinz.fragments.DatePickerFragment;
import org.julheinz.fragments.DeleteDialogFragment;
import org.julheinz.fragments.TimePickerFragment;
import org.julheinz.listadapters.ContactListAdapter;
import org.julheinz.entities.ContactEntity;
import org.julheinz.entities.TaskEntity;
import org.julheinz.madtodoapp.databinding.DetailViewBinding;
import org.julheinz.viewmodel.DetailviewViewModel;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;

public class DetailViewActivity extends AppCompatActivity implements DeleteDialogFragment.DeleteDialogListener, TimePickerDialog.OnTimeSetListener, DatePickerDialog.OnDateSetListener {
    private static final String LOG_TAG = DetailViewActivity.class.getSimpleName();

    public static final String ARG_TASK = "task";
    private DetailviewViewModel viewModel;
    public int doneCheckboxVisibility;


    public List<ContactEntity> localContactsList = new ArrayList<>(); //list of contactEntities for this task, used in ListView
    ArrayAdapter<ContactEntity> listViewAdapter;
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        DetailViewBinding itemBinding = DataBindingUtil.setContentView(this, R.layout.detail_view); //bind this activity to detail_view.xml
        // DetailViewBinding class gets automatically generated by data binding library. named after xml file (detail_view.xml -> DetailViewBinding.java)
        Intent detailViewIntentFromOverview = getIntent();
        String action = detailViewIntentFromOverview.getAction();



        this.viewModel = new ViewModelProvider(this).get(DetailviewViewModel.class);



        if (this.viewModel.getTaskEntity() == null) {
            //in case this activity gets called to edit a task, get the TaskEntity from intent
            TaskEntity taskFromIntent = (TaskEntity) detailViewIntentFromOverview.getSerializableExtra(ARG_TASK); // get TaskEntity (not same instance because it is serializable)
            TaskEntity task = taskFromIntent;
            if (taskFromIntent == null) { //in case this activity gets called to create a task instead of edit one, create a new TaskEntity
                task = new TaskEntity();
                Log.i(LOG_TAG, "created new empty task: " + task );
            }else{
                Log.i(LOG_TAG, "got task from overview " + task);
            }
            this.viewModel.setTaskEntity(task);
        }

        itemBinding.setViewmodel(this.viewModel);
        itemBinding.setActivity(this);
        itemBinding.setLifecycleOwner(this); // enable observing of view model
        //observe changes on the live data
        this.viewModel.getContactIdListLiveData().observe(this, listFromLiveData ->{
            for (String contactId : listFromLiveData){
                addToLocalContactEntityList(Long.parseLong(contactId)); // add newly added ids to LocalContentEntity list as ContentEntities
            }
            listViewAdapter.notifyDataSetChanged();
        });

        // listen to what the most recent user event is and act accordingly. user event gets set in layout databound to viewmodel
        this.viewModel.getUserEvent().observe(this, event ->{
            switch (event){
                case SET_DATE:
                    showDatePickerDialog();
                    break;
                case SET_TIME:
                    showTimePickerDialog();
                    break;
                case CANCEL:
                    cancelEdit();
                    break;
                case SAVE:
                    saveTask();
                    break;
                case FAVORITE:
                    //TODO: Method for toggling icon
                    break;
            }
        });


        Toolbar topAppBar = findViewById(R.id.topAppBar);
        setSupportActionBar(topAppBar);
        topAppBar.setNavigationOnClickListener(v -> cancelEdit());

        topAppBar.setOnMenuItemClickListener(item -> {
            if(item.getItemId() == R.id.addContact){
                selectContact();
                return true;
            }else if(item.getItemId() == R.id.deleteTask){
                //TODO: don't show this item in menu if task is being created
                confirmDeletionViaDialog();
                return true;
            }else{
                return false;
            }
        });



        ListView listView = findViewById(R.id.contactListView); // listview element in detailview_activity.xml = container for list
        //instantiate adapter
        listViewAdapter = new ContactListAdapter(this, R.id.contactListView, localContactsList,  this.getLayoutInflater());
        listView.setAdapter(listViewAdapter);

        // if action is called for creating a task, change layout
        if (Objects.equals(action, "android.intent.action.INSERT")) {
            prepareLayoutForCreate();
            Objects.requireNonNull(getSupportActionBar()).setTitle("New task");
        }else{
            Objects.requireNonNull(getSupportActionBar()).setTitle(viewModel.getTaskEntity().getTitle());

        }

    }

    public void saveTask() {
        Log.i(LOG_TAG, "Task saved:" + viewModel.getTaskEntity().toString());
        Intent returnToCallerWithValueIntent = new Intent(Intent.ACTION_EDIT);
        returnToCallerWithValueIntent.putExtra(ARG_TASK, viewModel.getTaskEntity()); //return created/updated task to calling activity
        setResult(Activity.RESULT_OK, returnToCallerWithValueIntent);
        finish(); //close activity and return to caller
    }

    public void cancelEdit() {
        Intent returnToCallerWhenCancelled = new Intent();
        setResult(Activity.RESULT_CANCELED, returnToCallerWhenCancelled);
        finish(); //close activity and return to caller
    }

    public void deleteTask() {
        Log.i(LOG_TAG, "Task deleted:" + viewModel.getTaskEntity().toString());
        Intent returnToCallerWithValueIntent = new Intent(Intent.ACTION_DELETE);
        returnToCallerWithValueIntent.putExtra(ARG_TASK, viewModel.getTaskEntity());
        setResult(Activity.RESULT_OK, returnToCallerWithValueIntent);
        finish(); //close activity and return to caller
    }

    /**
     * Show a dialog to confirm before deleting
     */
    public void confirmDeletionViaDialog() {
        DialogFragment dialogFragment = new DeleteDialogFragment();
        dialogFragment.show(getSupportFragmentManager(), "DeleteDialogFragment");
    }
    /**
     * Listener for confirm button in Confirm Deletion Dialog
     */
    @Override
    public void onDialogPositiveClick(DialogFragment dialog) {
        deleteTask();
    }

    /**
     * Listener for cancel button in Confirm Deletion Dialog
     */
    @Override
    public void onDialogNegativeClick(DialogFragment dialog) {
        dialog.dismiss();
    }

    public void showTimePickerDialog() {
        TimePickerFragment timePickerFragment = new TimePickerFragment(viewModel.getTaskEntity().getDueDate());
        timePickerFragment.show(getSupportFragmentManager(), "timePickerDueDate");
    }

    public void showDatePickerDialog() {
        DatePickerFragment datePickerFragment = new DatePickerFragment(viewModel.getTaskEntity().getDueDate());
        datePickerFragment.show(getSupportFragmentManager(), "datePickerDueDate");
    }

    /**
     * Listen to user finishing setting due time in TimePickerFragment in TimepickerDialog.
     */
    @Override
    public void onTimeSet(TimePicker view, int hourOfDay, int minute) {
        this.viewModel.getDateTimeHelper().getValue().setDueTime(hourOfDay, minute);
    }

    /**
     * Listen to user finishing setting due date in DatePickerDialog.
     */
    @Override
    public void onDateSet(DatePicker view, int year, int month, int dayOfMonth) {
        Log.i(LOG_TAG, "Set due date to: " + year + "/" + month + "/" + dayOfMonth);
        this.viewModel.getDateTimeHelper().getValue().setDueDate(year, month, dayOfMonth);
    }

    /**
     * Show different elements if activity was called for task creation
     */
    public void prepareLayoutForCreate() {
        setDoneCheckboxVisibility(View.GONE);

        //TODO: hide delete option in menu
    }

    public int getDoneCheckboxVisibility() {
        return doneCheckboxVisibility;
    }

    public void setDoneCheckboxVisibility(int doneCheckboxVisibility) {
        this.doneCheckboxVisibility = doneCheckboxVisibility;
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu){
        getMenuInflater().inflate(R.menu.activity_detailview_menu, menu);
        return true;
    }



    private void selectContact(){
        //Intent to call the app which is registered to handle contacts on the device
        Intent selectContactOIntent = new Intent(Intent.ACTION_PICK, ContactsContract.Contacts.CONTENT_URI);
        selectContactLauncher.launch(selectContactOIntent);
    }


    /**
     * This is field. ActivityResultLauncher to launch the intent to the contacts app and handle the result
     * Has two arguments:
     * 1. How the activity should be called (with result)
     * 2. what to do with the result
     */
    private final ActivityResultLauncher<Intent> selectContactLauncher = registerForActivityResult(
            new ActivityResultContracts.StartActivityForResult(),
            result -> {
                if(result.getResultCode() == Activity.RESULT_OK && (result.getData() != null) ){
                    onContactSelected(result.getData());
                }else{
                    String message = "Something went wrong with getting the contact";
                    showSnackbar(message);
                    Log.i(LOG_TAG, message);
                }
            }
    );


    /**
     * Get the ids of the selected contacts from the intent returned from the contacts app.
     * @param returnIntentFromContactsApp the contact that was returned from the contact app, wrapped in an intent
     */
    private void onContactSelected(Intent returnIntentFromContactsApp){
        Uri contactUri = returnIntentFromContactsApp.getData(); //get the uri for the contact e.g. content://com.android.contacts/contacts/lookup/0r6-344C2A445C3A4E3E2A/6

        // ContentResolver.query accesses the content in the given uri, acts like accessing a relational db.
        // That's why we can use java's cursor class (which is usually used to access the result set of a db query)

        try(Cursor cursor = getContentResolver().query(contactUri, null, null, null)){
            if (cursor.moveToFirst()) {
                int displayNameColumnIndex = cursor.getColumnIndex(ContactsContract.Contacts.DISPLAY_NAME); //get the index for the column for the contact name
                String contactName = cursor.getString(displayNameColumnIndex);
                int contactIdColumnIndex = cursor.getColumnIndex(ContactsContract.Contacts._ID);
                long contactID = cursor.getLong(contactIdColumnIndex);
                Log.i(LOG_TAG, "Contact selected by user: " +  contactID + " " + contactName);
                //check if permission to read contacts has already been granted
                //TODO: Something with permissions and returning from this method
                int hasReadContactPermission = checkSelfPermission(Manifest.permission.READ_CONTACTS);
                if(hasReadContactPermission != PackageManager.PERMISSION_GRANTED){
                    //if not, ask user for permission
                    requestPermissions(new String[]{Manifest.permission.READ_CONTACTS}, 10);
                }else {
                    this.viewModel.addToContactsListOfEntity(contactID);
                }

            }
        }
    }


    public String getContactName(long id){
        String contactName = "";

        String[] contactIDs = new String[]{String.valueOf((id))};
        try(Cursor cursor = getContentResolver().query(ContactsContract.Data.CONTENT_URI, null, "contact_id=?", contactIDs, null)){
            while(cursor.moveToNext()){
                int displayNameColumnIndex = cursor.getColumnIndex(ContactsContract.Contacts.DISPLAY_NAME); //get the index for the column for the contact name
                contactName = cursor.getString(displayNameColumnIndex);
            }
            return contactName;
        }

    }


    @Override
    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults);
        Log.i(LOG_TAG, "onRequestPermissionsResult: " + Arrays.asList(permissions) + ": " + Arrays.toString(grantResults));
    }


    /**
     * get phone from selected contact
     */
    private String getMobileNr(long id){
        String currentPhoneNumber = "";
        int currentNumberType = 0;

        //get phone book data, like in sql SELECT * FROM Phone WHERE contactId = contactId
        // 1. what table to select from, here phone
        // 2. what columns to get: null means all (like * in SQL)
        // 3. query
        // 4. what gets inserted at ? for the above query, as String array
        // 5. sort order
        String[] contactIDs = new String[]{String.valueOf((id))};
        try(Cursor cursor = getContentResolver().query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI, null, "contact_id=?", contactIDs, null)){
            while(cursor.moveToNext()){
                int phoneNumberColumnIndex = cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER);
                int phoneNumberTypeColumnIndex = cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.TYPE);
                currentPhoneNumber  = cursor.getString(phoneNumberColumnIndex);
                currentNumberType = cursor.getInt(phoneNumberTypeColumnIndex);
            }
        }
        if(currentNumberType == ContactsContract.CommonDataKinds.Phone.TYPE_MOBILE){
            return currentPhoneNumber;
        }else {
            return "";
        }
    }

    public String getEmail(long id){
        String[] contactIDs = new String[]{String.valueOf(id)};
        String email = "";
        try(Cursor cursor = getContentResolver().query(ContactsContract.CommonDataKinds.Email.CONTENT_URI, null, "contact_id=?", contactIDs, null)){
            while(cursor.moveToNext()){
                int emailColumnIndex = cursor.getColumnIndex(ContactsContract.CommonDataKinds.Email.ADDRESS);
                email = cursor.getString(emailColumnIndex);
            }
        }
        return email;
    }

    private void showSnackbar(String msg) {
        Snackbar.make(findViewById(R.id.DetailView), msg, Snackbar.LENGTH_SHORT).show();
    }

    /**
     * Create a contactEntity from an id, then add it to the list that is used by the listview
     */
    private void addToLocalContactEntityList(long contactID){
        //check if contactEntity with that id already exists. (only id is relevant here, since equals is overwritten to only consider id)
        if(!localContactsList.contains(new ContactEntity(contactID, null, null, null))){
            String phone = getMobileNr(contactID);
            String email = getEmail(contactID);
            String contactName = getContactName(contactID);
            ContactEntity contactEntity = new ContactEntity(contactID, contactName,email, phone);
            localContactsList.add(contactEntity);
            Log.i(LOG_TAG, "Following contact has been added to local contacts list" + contactEntity);
            listViewAdapter.notifyDataSetChanged();
        }else{
            Log.i(LOG_TAG, "Contact already added");
        }

    }

    /**
     * Delete local contact Entity in list used for list view as well as contact in taskEntity in viewmodel
     */
    public void deleteContact(long contactID){
        Log.i(LOG_TAG, "Attempting to remove contact with id" + contactID);
        ContactEntity contactToBeRemoved = new ContactEntity(contactID, null, null, null);
        localContactsList.remove(contactToBeRemoved);
        Log.i(LOG_TAG, "Local contact list after deleting of contact:" + localContactsList.toString());
        viewModel.removeFromContactsListOfEntity(contactID); //also delete from entity, so the contact doesn't get saved
        listViewAdapter.notifyDataSetChanged();
    }

    public void sendEmailToContact(String address){
        Log.i(LOG_TAG, "Attempting to send email to adress" + address);
        Intent intent = new Intent(Intent.ACTION_SENDTO);
        intent.setData(Uri.parse("mailto:")); // Only email apps handle this.
        intent.putExtra(Intent.EXTRA_EMAIL, address);
        intent.putExtra(Intent.EXTRA_SUBJECT, "New task!");
        intent.putExtra(Intent.EXTRA_TEXT, getMessageForContact());
        startActivity(intent);
    }

    public void sendSMSToContact(String number){
        Uri uri = Uri.parse("smsto:" + number);
        Intent intent = new Intent(Intent.ACTION_SENDTO, uri);
        intent.putExtra("sms_body", getMessageForContact());
        Log.i(LOG_TAG, "Attempting to send sms to nr: " + number);

        startActivity(intent);
    }

    public String getMessageForContact(){
        String dueDate = viewModel.getTaskEntity().getFullDueDateFormatted();
        String taskTitle = viewModel.getTaskEntity().getTitle();
        String taskDescription = viewModel.getTaskEntity().getDescription();
        String messageBody = "Here is a new task for you! Title: "  + taskTitle;
        if(!taskDescription.isEmpty()){
            messageBody = messageBody + " | Description: " + taskDescription;
        }
        if(!dueDate.isEmpty()){
            messageBody = messageBody + " | Due: " + dueDate;
        }
        return messageBody;
    }

}



